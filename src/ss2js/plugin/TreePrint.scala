package ss2js.plugin

import java.io.PrintWriter
import scala.tools.nsc.Global

/**
 * Print JavaScript to given output.
 */
class TreePrint[G <: Global](val global: G)(out: PrintWriter) extends Utility {

  import global._

  def print(unit: CompilationUnit) = myprint.print(unit)

  val myprint = new TreePrinter(out) {
    override val indentStep = 4
    private val scope = new NameScope

    override def print(unit: CompilationUnit) {
      var body = unit.body
      val trans = List(
          new TrimTrans[global.type](global),
          new MangleTrans[global.type](global),
          new ExprTrans[global.type](global),
          new FlattenTrans[global.type](global)
          )
      trans.foreach { t =>
        if(!reporter.hasErrors) {
          trace("------------ " + t);
          body = t.transform(body)
        }
      }
      if(!reporter.hasErrors) {
        print("// Generated by ss2js from " + unit.source + "\n")
        // TODO: ss2js lib
        print(body)
        println()
        flush()
      }
    }

    override def printRaw(tree: Tree) = tree match {

      case p: PackageDef => doPackage(p)
      case c: ClassDef => doClass(c)
      case m: ModuleDef => doClass(m)

      case d @ DefDef(mods, name, tparams, vparamss, tp, rhs) =>
        scope.addPush(d)
        if(!tree.symbol.owner.isClass) { print("function "); print(name) }
        else {
          print(tree.symbol.owner.name); print(".prototype.")
          print(name); print(" = function")
        }
        printValueParams(vparamss.flatten)
        printBlock(rhs)
        scope.pop()

      case f @ Function(vparams, body) =>
        scope.addPush(f)
        print("function")
        printValueParams(vparams)
        printBlock(body)
        scope.pop()

      // TODO: Block not doing braces in all places
      case Block(List(stat), Literal(Constant(()))) =>
        print(stat)

      case Block(stat, Literal(Constant(()))) =>
        print(stat)

      case Block(List(), expr) =>
        print(expr)

      case Block(stats, expr) =>
         print(stats :+ expr)

      case ValDef(mods, name, tp, rhs) =>
        if(!tree.symbol.owner.isClass) print("var ")
        else if(tree.symbol.isStatic) { print(tree.symbol.owner.name); print(".prototype.") }
        else print("this.")
        print(name)
        if(tree.symbol.isParamAccessor) { print(" = "); print(name) }
        else if(!rhs.isEmpty) { print(" = "); print(rhs) }

      case If(cond, thenp, elsep) =>
        print("if("); print(cond); print(") "); print(thenp)
        if (!isUnit(elsep)) {
          println(); print("else "); print(elsep)
        }

      case l: LabelDef => doLabel(l)
      case m: Match => doMatch(m)
      case t: Try => doTry(t)

      case Apply(Select(_, name), List(Literal(Constant(jscript: String))))
      if(doName(name) == "jsni") => // native javascript method
        print(jscript)

      case Apply(fun @ Select(qual, name), vargs)  // operator
      if(name.isOperatorName && vargs.length == 1 && !fun.symbol.isConstructor) =>
        print(fun); print(" "); print(vargs(0))

      case Apply(fun, vargs) =>  // function call
        print(fun); printRow(vargs, "(", ", ", ")")

      case Select(qual, name) if(qual.isInstanceOf[New]) =>
        print(qual)

      case s @ Select(qual, name) if(name.decode == "apply" && s.symbol.isDeferred) =>
        print(qual)

      case Select(qual, name) if(name == nme.CONSTRUCTOR) =>
        print(qual); print(".constructor")

      case Select(qual, name) if(name.startsWith("unary_")) =>
        print(name.decode.drop(6)); print(qual)

      case Select(qual, name) if(name.endsWith("_$eq")) =>
        print(qual); print("."); print(name.decode.dropRight(2)); print(" =")

      case Select(qual, name) if(name.isOperatorName) =>
        print(qual); print(" "); print(name.decode)

      case Select(qual, name) =>
        print(qual); print("."); print(name)

      case TypeApply(fun, args) =>
        print(fun)

      case Assign(lhs, rhs) =>
        print(lhs); print(" = "); print(rhs)

      case t: This => doThis(t)

      // TODO: these probably need to descend - redo New and Super
      case New(tpt) =>
        print("new "); print(tpt.symbol.name) // + doTree(tpt) - TODO: handle other package types

      case s @ Super(qual, mix) =>
        print(s.symbol.superClass.name); print(".prototype")

      case Throw(expr) =>
        print("throw "); print(expr)

      case Return(expr) =>
        print("return "); print(expr)

      case Ident(name) =>
        print(name)

      case Literal(Constant(())) =>
        print("undefined")

//      case Literal(Constant(value: String)) =>
//        print("\"" + value + "\"")

      case l: Literal =>
        print(l.toString)

      case t: TypeDef => // ignore

      case t: Tree if(t.isEmpty) =>
        print(" /* empty */ ")

      case _ =>
        error(tree, "not handled: " + tree.getClass().getSimpleName())
        super.printRaw(tree)
    }

    /** package */
    private def doPackage(p: PackageDef) {
      print("(function() {"); indent; println()
      // TODO: handle multiple packages and multiple files
      // TODO: fix generation of octal for \n in print
//      print("\"use strict\";"); println()
      // ss2js methods
      print("function " + INHERITS + "(child, parent, traits) {"); indent; println()
        print("function F() {}"); println()
        print("F.prototype = parent.prototype;"); println()
        print("child.prototype = new F();"); println()
        print("child.prototype.constructor = child;"); println()
//        "child.prototype.ss2js_traits = traits" + nl +
        print("for(var i = traits.length - 1; i >= 0; --i) {"); indent; println()
        print("var p = traits[i].prototype"); println()
        print("for(var f in p) if(p.hasOwnProperty(f)) child.prototype[f] = p[f]")
        undent; println(); print("}")
//        "child.prototype.prototype = parent.prototype;" +
//        "child.prototype.__proto__ = parent.prototype;" +
      undent; println(); print("}")
      println()
      print("function ScalaObject() {}  // placeholder"); println()

      p.stats.foreach(print); println()

      p.stats.filter(hasMain).map { i =>
        print(i.symbol.name); print(".main();"); println();
      }
      undent; println(); print("}());")
    }

    /** class, object or trait */
    private def doClass(c: ImplDef) {
      val name = scope.addPush(c)
      val body = c.impl.body
      val (defs, others) = body.partition(t =>
        t.isInstanceOf[DefDef] ||(t.hasSymbol && t.symbol.isSynthetic))
      val (ctors, methods) = defs.partition(_.symbol.isConstructor)

      // make ctor function
      println()
      if(ctors.isEmpty) {
        print("function " + name + "() {}  // placeholder for trait")
      }
      else {
        print("function " + name)
        val ctor = ctors.head.asInstanceOf[DefDef]
        val args = ctor.vparamss
        printValueParams(args.flatten)
        // TODO: call trait init methods
        var trees = ctor.rhs :: others
        if(!c.symbol.isTrait) {
          val argslen = ctor.vparamss.flatten.length
          trees = Ident("if(arguments[" + argslen + "]) " +
            "this." + OUTER + " = arguments[" + argslen + "]") :: trees
        }
        print(trees)
        println()
      }

      // setup inheritence
      if(!c.symbol.isTrait) {
        val parent = doName(c.symbol.superClass.name)
        val traits = c.symbol.mixinClasses.
            map(i => doName(i.name)).mkString("[", ", ", "]")
        print(INHERITS + "(" + name + ", " + parent + ", " + traits + ")")
        println()
      }

      // add methods
      printSeq(methods)(print)(println)

      // create as object if required
      if(c.symbol.hasModuleFlag) {
        // TODO: recheck
        println()
        if(c.symbol.owner.isClass && !c.symbol.owner.hasPackageFlag)
          print("this.")
        else
          print("var ")
        print(name + " = new " + name + "(this);  // object")
      }

      scope.pop()
    }

    /** do while */
    private def doLabel(l: LabelDef) = l.rhs match {
      case Block(block, If(cond, _, _)) if l.name.startsWith(nme.DO_WHILE_PREFIX) =>
        print("do "); print(block); println()
        print("while("); print(cond); print(")")
      case If(cond, Block(block, _), _) if l.name.startsWith(nme.WHILE_PREFIX) =>
        print("while("); print(cond); print(") ")
        print(block)
      case _ => error(l, "unrecognized LabelDef")
    }

    /** basic match as switch */
    private def doMatch(m : Match) {

      def patternMatch(pat: Tree): Unit = pat match {
        case Alternative(list) => // multiple cases with same action
          list.foreach(patternMatch)
        case Literal(_) => // general case
          print("case "); print(pat); print(": ")
        case Ident(nme.WILDCARD) => // default case
          print("default: ")
        case _ =>
          error(pat, "pattern not supported, too complex")
      }

      print("switch("); print(m.selector); print(") {"); indent(); println()

      m.cases.foreach { c =>
        patternMatch(c.pat); print(c.body); println(); print("break;"); println()
      }

      undent(); println(); print("}")
    }

    /** try catch finally */
    private def doTry(t: Try) = {

      def catchName(pat: Tree) = pat match {
        case Ident(_) => "ss2js_error"
        case Bind(name, Ident(_)) => doName(name)
        case _ => error(pat, "only simple names supported")
      }

      print("try"); printBlock(t.block); println()

      t.catches match {
        case List() =>
        case List(CaseDef(pat, guard, body)) =>
          print("catch(" + catchName(pat) + ")"); printBlock(body); println()
        case _ => error(t.catches(1), "only one catch allowed")
      }

      if(t.catches.isEmpty || !t.finalizer.isEmpty) {
        print("finally"); printBlock(t.finalizer)
      }
    }

    /** find correct this at different levels in heirarchy */
    private def doThis(t: This): Unit = {

      val chain = scope.symbol.enclClassChain
      def doError(msg: String) = { error(t, msg + ": " + t.symbol + "  " + chain); "" }

      def findThis(chain: List[Symbol]): String = {
        if(chain.isEmpty) doError("did not find outer")
        else if(chain.head == NoSymbol) doError("NoSymbol in chain")
        else if(t.symbol == chain.head) "this"
        else findThis(chain.tail) + "." + OUTER
      }

      if(t.symbol.hasModuleFlag)
        if(t.qual.nonEmpty) print(t.qual) else print("this")
      else
        print(findThis(chain))
    }

    def print(trees: List[Tree]) = printColumn(trees, " {", "", "}")

    override def printBlock(tree: Tree) = {
      printColumn(List(tree), " {", "", "}")
    }

    override def print(name: Name) { print(name.decode.trim) }
    override def printParam(tree: Tree) { print(tree.symbol.name) }
    override def printFlags(flags: Long, privateWithin: String) {}
    override def printTypeParams(ts: List[TypeDef]) {}
    override def printAnnotations(tree: Tree) {}
  }

}
