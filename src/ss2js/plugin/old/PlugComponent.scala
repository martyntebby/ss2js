package ss2js.plugin.old

import java.io.PrintWriter
import scala.tools.nsc.plugins.PluginComponent
import scala.tools.nsc.Global
import scala.tools.nsc.Phase
import scala.collection.mutable.Stack
import scala.collection.mutable.HashSet

/**
 * Main plugin functionality.
 * Contains a number of transformers to convert scala AST to JavaScript.
 * Would prefer the transformers to have own files,
 * but causes problems with global import.
 */
class PlugComponent(
    val global: Global, val phaseName: String,
    runAfter: String, verbose: Boolean)
    extends PluginComponent {

  import global._

  val runsAfter = List(runAfter)
  override val runsRightAfter = Some(runAfter)

  def newPhase(prev: Phase) = new StdPhase(prev) {
    def apply(unit: CompilationUnit) {
      val outfile = global.settings.outdir.value +
          java.io.File.separator + unit.source + ".js"
      val out = new PrintWriter(outfile)
      new MyTreePrinter(out).print(unit)
      out.close()
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  /**
   * Print JavaScript to given output.
   */
  class MyTreePrinter(out: PrintWriter) extends TreePrinter(out) {

    override val indentStep = 4
    private val scope = new NameScope

    override def print(unit: CompilationUnit) {
      var body = unit.body
      val trans = List(new TrimTrans, new MangleTrans, new ExprTrans, new FlattenTrans)
      trans.foreach { t =>
        if(!reporter.hasErrors) {
          trace("------------ " + t);
          body = t.transform(body)
        }
      }
      if(!reporter.hasErrors) {
        print("// Generated by ss2js from " + unit.source + "\n")
        // TODO: ss2js lib
        print(body)
        println()
        flush()
      }
    }

    override def printRaw(tree: Tree) = tree match {

      case p: PackageDef => doPackage(p)
      case c: ClassDef => doClass(c)
      case m: ModuleDef => doClass(m)

      case d @ DefDef(mods, name, tparams, vparamss, tp, rhs) =>
        scope.addPush(d)
        if(!tree.symbol.owner.isClass) { print("function "); print(name) }
        else {
          print(tree.symbol.owner.name); print(".prototype.")
          print(name); print(" = function")
        }
        printValueParams(vparamss.flatten)
        printBlock(rhs)
        scope.pop()

      case f @ Function(vparams, body) =>
        scope.addPush(f)
        print("function")
        printValueParams(vparams)
        printBlock(body)
        scope.pop()

      // TODO: Block not doing braces in all places
      case Block(List(stat), Literal(Constant(()))) =>
        print(stat)

      case Block(stat, Literal(Constant(()))) =>
        print(stat)

      case Block(List(), expr) =>
        print(expr)

      case Block(stats, expr) =>
         print(stats :+ expr)

      case ValDef(mods, name, tp, rhs) =>
        if(!tree.symbol.owner.isClass) print("var ")
        else if(tree.symbol.isStatic) { print(tree.symbol.owner.name); print(".prototype.") }
        else print("this.")
        print(name)
        if(tree.symbol.isParamAccessor) { print(" = "); print(name) }
        else if(!rhs.isEmpty) { print(" = "); print(rhs) }

      case If(cond, thenp, elsep) =>
        print("if("); print(cond); print(") "); print(thenp)
        if (!isUnit(elsep)) {
          println(); print("else "); print(elsep)
        }

      case l: LabelDef => doLabel(l)
      case m: Match => doMatch(m)
      case t: Try => doTry(t)

      case Apply(Select(_, name), List(Literal(Constant(jscript: String))))
      if(doName(name) == "jsni") => // native javascript method
        print(jscript)

      case Apply(fun @ Select(qual, name), vargs)  // operator
      if(name.isOperatorName && vargs.length == 1 && !fun.symbol.isConstructor) =>
        print(fun); print(" "); print(vargs(0))

      case Apply(fun, vargs) =>  // function call
        print(fun); printRow(vargs, "(", ", ", ")")

      case Select(qual, name) if(qual.isInstanceOf[New]) =>
        print(qual)

      case s @ Select(qual, name) if(name.decode == "apply" && s.symbol.isDeferred) =>
        print(qual)

      case Select(qual, name) if(name == nme.CONSTRUCTOR) =>
        print(qual); print(".constructor")

      case Select(qual, name) if(name.startsWith("unary_")) =>
        print(name.decode.drop(6)); print(qual)

      case Select(qual, name) if(name.endsWith("_$eq")) =>
        print(qual); print("."); print(name.decode.dropRight(2)); print(" =")

      case Select(qual, name) if(name.isOperatorName) =>
        print(qual); print(" "); print(name.decode)

      case Select(qual, name) =>
        print(qual); print("."); print(name)

      case TypeApply(fun, args) =>
        print(fun)

      case Assign(lhs, rhs) =>
        print(lhs); print(" = "); print(rhs)

      case t: This => doThis(t)

      // TODO: these probably need to descend - redo New and Super
      case New(tpt) =>
        print("new "); print(tpt.symbol.name) // + doTree(tpt) - TODO: handle other package types

      case s @ Super(qual, mix) =>
        print(s.symbol.superClass.name); print(".prototype")

      case Throw(expr) =>
        print("throw "); print(expr)

      case Return(expr) =>
        print("return "); print(expr)

      case Ident(name) =>
        print(name)

      case Literal(Constant(())) =>
        print("undefined")

//      case Literal(Constant(value: String)) =>
//        print("\"" + value + "\"")

      case l: Literal =>
        print(l.toString)

      case t: TypeDef => // ignore

      case t: Tree if(t.isEmpty) =>
        print(" /* empty */ ")

      case _ =>
        error(tree, "not handled: " + tree.getClass().getSimpleName())
        super.printRaw(tree)
    }

    /** package */
    private def doPackage(p: PackageDef) {
      print("(function() {"); indent; println()
      // TODO: handle multiple packages and multiple files
      // TODO: fix generation of octal for \n in print
//      print("\"use strict\";"); println()
      // ss2js methods
      print("function " + INHERITS + "(child, parent, traits) {"); indent; println()
        print("function F() {}"); println()
        print("F.prototype = parent.prototype;"); println()
        print("child.prototype = new F();"); println()
        print("child.prototype.constructor = child;"); println()
//        "child.prototype.ss2js_traits = traits" + nl +
        print("for(var i = traits.length - 1; i >= 0; --i) {"); indent; println()
        print("var p = traits[i].prototype"); println()
        print("for(var f in p) if(p.hasOwnProperty(f)) child.prototype[f] = p[f]")
        undent; println(); print("}")
//        "child.prototype.prototype = parent.prototype;" +
//        "child.prototype.__proto__ = parent.prototype;" +
      undent; println(); print("}")
      println()
      print("function ScalaObject() {}  // placeholder"); println()

      p.stats.foreach(print); println()

      p.stats.filter(hasMain).map { i =>
        print(i.symbol.name); print(".main();"); println();
      }
      undent; println(); print("}());")
    }

    /** class, object or trait */
    private def doClass(c: ImplDef) {
      val name = scope.addPush(c)
      val body = c.impl.body
      val (defs, others) = body.partition(t =>
        t.isInstanceOf[DefDef] ||(t.hasSymbol && t.symbol.isSynthetic))
      val (ctors, methods) = defs.partition(_.symbol.isConstructor)

      // make ctor function
      println()
      if(ctors.isEmpty) {
        print("function " + name + "() {}  // placeholder for trait")
      }
      else {
        print("function " + name)
        val ctor = ctors.head.asInstanceOf[DefDef]
        val args = ctor.vparamss
        printValueParams(args.flatten)
        // TODO: call trait init methods
        var trees = ctor.rhs :: others
        if(!c.symbol.isTrait) {
          val argslen = ctor.vparamss.flatten.length
          trees = Ident("if(arguments[" + argslen + "]) " +
            "this." + OUTER + " = arguments[" + argslen + "]") :: trees
        }
        print(trees)
        println()
      }

      // setup inheritence
      if(!c.symbol.isTrait) {
        val parent = doName(c.symbol.superClass.name)
        val traits = c.symbol.mixinClasses.
            map(i => doName(i.name)).mkString("[", ", ", "]")
        print(INHERITS + "(" + name + ", " + parent + ", " + traits + ")")
        println()
      }

      // add methods
      printSeq(methods)(print)(println)

      // create as object if required
      if(c.symbol.hasModuleFlag) {
        // TODO: recheck
        println()
        if(c.symbol.owner.isClass && !c.symbol.owner.hasPackageFlag)
          print("this.")
        else
          print("var ")
        print(name + " = new " + name + "(this);  // object")
      }

      scope.pop()
    }

    /** do while */
    private def doLabel(l: LabelDef) = l.rhs match {
      case Block(block, If(cond, _, _)) if l.name.startsWith(nme.DO_WHILE_PREFIX) =>
        print("do "); print(block); println()
        print("while("); print(cond); print(")")
      case If(cond, Block(block, _), _) if l.name.startsWith(nme.WHILE_PREFIX) =>
        print("while("); print(cond); print(") ")
        print(block)
      case _ => error(l, "unrecognized LabelDef")
    }

    /** basic match as switch */
    private def doMatch(m : Match) {

      def patternMatch(pat: Tree): Unit = pat match {
        case Alternative(list) => // multiple cases with same action
          list.foreach(patternMatch)
        case Literal(_) => // general case
          print("case "); print(pat); print(": ")
        case Ident(nme.WILDCARD) => // default case
          print("default: ")
        case _ =>
          error(pat, "pattern not supported, too complex")
      }

      print("switch("); print(m.selector); print(") {"); indent(); println()

      m.cases.foreach { c =>
        patternMatch(c.pat); print(c.body); println(); print("break;"); println()
      }

      undent(); println(); print("}")
    }

    /** try catch finally */
    private def doTry(t: Try) = {

      def catchName(pat: Tree) = pat match {
        case Ident(_) => "ss2js_error"
        case Bind(name, Ident(_)) => doName(name)
        case _ => error(pat, "only simple names supported")
      }

      print("try"); printBlock(t.block); println()

      t.catches match {
        case List() =>
        case List(CaseDef(pat, guard, body)) =>
          print("catch(" + catchName(pat) + ")"); printBlock(body); println()
        case _ => error(t.catches(1), "only one catch allowed")
      }

      if(t.catches.isEmpty || !t.finalizer.isEmpty) {
        print("finally"); printBlock(t.finalizer)
      }
    }

    /** find correct this at different levels in heirarchy */
    private def doThis(t: This): Unit = {

      val chain = scope.symbol.enclClassChain
      def doError(msg: String) = { error(t, msg + ": " + t.symbol + "  " + chain); "" }

      def findThis(chain: List[Symbol]): String = {
        if(chain.isEmpty) doError("did not find outer")
        else if(chain.head == NoSymbol) doError("NoSymbol in chain")
        else if(t.symbol == chain.head) "this"
        else findThis(chain.tail) + "." + OUTER
      }

      if(t.symbol.hasModuleFlag)
        if(t.qual.nonEmpty) print(t.qual) else print("this")
      else
        print(findThis(chain))
    }

    def print(trees: List[Tree]) = printColumn(trees, " {", "", "}")

    override def printBlock(tree: Tree) = {
      printColumn(List(tree), " {", "", "}")
    }

    override def print(name: Name) { print(name.decode.trim) }
    override def printParam(tree: Tree) { print(tree.symbol.name) }
    override def printFlags(flags: Long, privateWithin: String) {}
    override def printTypeParams(ts: List[TypeDef]) {}
    override def printAnnotations(tree: Tree) {}
  }

  ///////////////////////////////////////////////////////////////////////////

  /**
   * Change tree structure closer to JavaScript.
   * Add return to method and function.
   * Add class outer vars.
   * Flatten multiple method argument lists and add empty one when none.
   */
  class MangleTrans extends Transformer {

    override def transform(tree: Tree): Tree = {
    trace(treeInfo(tree))
    tree match {

      case DefDef(mods, name, tparams, vparamss, tpt, rhs) =>
        // add return to method
        super.transform(DefDef(tree.symbol, returnWrap(tree, rhs)))

      case Function(vparams, body) =>
        treeCopy.Function(tree, transformValDefs(vparams),
            transform(returnWrap(tree, body)))  // add return to function

      case Apply(Apply(fun, args1), args2) => // collapse multiple param lists
        transform(treeCopy.Apply(tree, fun, args1 ++ args2))

      case Apply(s @ Select(New(tpt), name), args) => // add outer arg to ctor call
        treeCopy.Apply(tree, super.transform(s), transformTrees(args :+ Ident("this")))

      case Apply(fun, args) => // add Function to by name params
        val params = tree.symbol.paramss.flatten
        treeCopy.Apply(tree, transform(fun), (args zip params) map { i =>
          if(definitions.isByNameParamType(i._2.tpe))
            treeCopy.Function(tree, Nil, transform(returnWrap(tree, i._1)))
          else
            transform(i._1)
        })

      case Select(Super(qual, mix), name) => // add call to super
        treeCopy.Apply(tree, treeCopy.Select(tree, super.transform(tree), "call"), List(Ident("this")))

      case s @ Select(qual, name) if(s.symbol.isMethod && s.symbol.paramss.isEmpty
          && !s.symbol.name.isOperatorName && !s.symbol.hasAccessorFlag) =>
            // prepend apply to Select method
        treeCopy.Apply(tree, super.transform(tree), Nil)

      case i @ Ident(name) if((i.symbol.isMethod && i.symbol.paramss.isEmpty)
          || i.symbol.isByNameParam) => // prepend apply to Ident method
        treeCopy.Apply(tree, super.transform(tree), Nil)

      case _ =>
        super.transform(tree)
    }
    }

    // prepend return to method body
    def returnWrap(owner: Tree, body: Tree) = {
      if(isUnitish(body))
        body
      else
        treeCopy.Return(owner, body)
    }

  }

  ///////////////////////////////////////////////////////////////////////////

  /**
   * Flatten multiple method argument lists and add empty one when none.
   * It is needed twice at present.
   */
  class FlattenTrans extends Transformer {

    override def transform(tree: Tree): Tree =
    tree match {
      case Apply(Apply(fun, args1), args2) => // collapse multiple param lists
        transform(treeCopy.Apply(tree, fun, args1 ++ args2))

      case _ =>
        super.transform(tree)
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  /**
   * Remove accessor methods, abstract methods, unused trees, aliases.
   * Signal error for unsupported constructs.
   * Detect duplicate names.
   */
  class TrimTrans extends Transformer {
    private val scope = new NameScope

    override def transform(tree: Tree): Tree = {
    trace(treeInfo(tree))
    tree match {

      case p: PackageDef =>
        scope.scope(p) { super.transform(tree) }

      case _: Import =>
        EmptyTree  // remove import

      case i: ImplDef =>
        if(i.mods.isCase)
          error(tree, "case class not supported")
        if(i.symbol.isTrait && !i.symbol.isInterface) {
          error(i, "non interface trait not supported")
        }
        scope.scope(i) { super.transform(tree) }

      case v @ ValDef(mods, name, tpt, rhs) =>
        if(v.symbol.alias != NoSymbol) {  // remove alias
          // TODO: maybe check for paramaccessor
          if(v.symbol.alias.decodedName.trim != v.symbol.decodedName.trim)
            error(tree, "use same name for aliased variable " + v.symbol.alias.name)
          return EmptyTree
        }
        if(v.mods.isLazy)
          error(tree, "lazy not supported")
        scope.add(v)
        super.transform(tree)

      case d @ DefDef(mods, name, tparams, vparamss, tpt, rhs) =>
        val symbol = tree.symbol
        if(mods.isDeferred)  // remove abstract method
          return EmptyTree
        if(symbol.hasAccessorFlag) {  // remove accessor
          if(symbol.isOverride)
            error(tree, "override val not supported")
          return EmptyTree
        }
        /*
        // Maybe bring back later
        if(symbol.isSynthetic && symbol.hasDefaultFlag) {
          // convert default method parameter to val
          rhs match {
            case _: Literal => // TODO: define const properly - use flag
            case _ => error(rhs, "constant defaults only")
          }
          if(vparamss.nonEmpty)
            error(rhs, "default param with multiple param lists nor supported")
          return treeCopy.ValDef(tree, transformModifiers(mods), name, transform(tpt), transform(rhs))
        }
        */
        if(symbol.isConstructor && !symbol.isPrimaryConstructor)
          error(tree, "multiple constructors not supported")
        if(name.endsWith("_$eq"))
          error(tree, "overriding = not supported")
        if(symbol.isVarargsMethod)
          error(tree, "varargs not supported")
        scope.scope(d) { super.transform(tree) }

      case f: Function =>
        scope.scope(f) { super.transform(tree) }

      case c: CaseDef =>
        if(!c.guard.isEmpty)
          error(c.guard, "guard not supported")
        super.transform(tree)

      case t: Try =>
        if(t.catches.length > 1)
          error(t.catches(1), "multiple catches not supported")
        super.transform(tree)

      case _ =>
        super.transform(tree)
    }
    }

    // check for varargs
    override def transformValDef(tree: ValDef): ValDef = {
      if(global.treeInfo.isRepeatedParamType(tree.tpt))
        error(tree.tpt, "varargs not supported")
      if (tree.isEmpty) tree else transform(tree).asInstanceOf[ValDef]
    }

    // check default case is the last
    override def transformCaseDefs(trees: List[CaseDef]): List[CaseDef] = {
      if(trees.nonEmpty)
        trees.last.pat match {
          case Ident(_) =>
          case Bind(_, Ident(_)) =>
          case _ => warning(trees.last.pat, "last case is not default")
        }
      super.transformCaseDefs(trees)
    }

  }

  ///////////////////////////////////////////////////////////////////////////
  
  /**
   * Convert scala expressions to JS statements.
   * Push val, assign, return and throw down to JS expression.
   * E.g.  val a = { 1; 2 }  ->  { 1; val a = 2 }
   * 
   * TODO: should expand to all binary operators     
   */
  class ExprTrans extends Transformer {

    override def transform(tree: Tree) = transform(tree, t => t)

    def transform(tree: Tree, prefix: Tree => Tree): Tree = {

      trace(treeInfo(tree))
      tree match {

        // Assignments - create prefix

        case ValDef(mods, name, tpt, rhs)
            if(!tree.symbol.isParameter && !tree.symbol.isParamAccessor) =>
          transform(rhs, treeCopy.ValDef(tree, transformModifiers(mods), name, transform(tpt), _))

        case Assign(lhs, rhs) =>
          transform(rhs, treeCopy.Assign(tree, transform(lhs), _))

        case Return(expr) =>
          transform(expr, treeCopy.Return(tree, _))

        case Throw(expr) =>
          transform(expr, treeCopy.Throw(tree, _))

        case Apply(fun @ Select(_, name), List(arg)) if(name.endsWith("_$eq")) =>
          transform(arg, arg2 => treeCopy.Apply(tree, transform(fun), List(arg2)))

        // JS Statements - pass through prefix

        case Block(stats, expr) =>
          treeCopy.Block(tree, transformStats(stats, null), transform(expr, prefix))

        case If(cond, thenp, elsep) =>
          treeCopy.If(tree, transform(cond), transform(thenp, prefix), transform(elsep, prefix))

        case Match(selector, cases) =>
          treeCopy.Match(tree, transform(selector), transformCaseDefs(cases, prefix))

        case CaseDef(pat, guard, body) =>
          treeCopy.CaseDef(tree, transform(pat), transform(guard), transform(body, prefix))

        case Try(block, catches, finalizer) =>
          treeCopy.Try(tree, transform(block, prefix), transformCaseDefs(catches, prefix), transform(finalizer))

        // JS Expressions - apply prefix

        case Function(vparams, body) =>
          prefix(treeCopy.Function(tree, transformValDefs(vparams), transform(body)))

        case Apply(fun, args) =>
          prefix(treeCopy.Apply(tree, transform(fun), transformTrees(args)))

        case Select(qualifier, selector) =>
          prefix(treeCopy.Select(tree, transform(qualifier), selector))

        case Ident(name) =>
          prefix(treeCopy.Ident(tree, name))

        case Literal(value) =>
          prefix(treeCopy.Literal(tree, value))

        case _ =>
          val pretree = prefix(tree)
          if(pretree != tree)
            error(pretree, "cannot convert operation, try using temp variable: " + tree.symbol)
          super.transform(tree)
      }
    }

    def transformCaseDefs(trees: List[CaseDef], prefix: Tree => Tree) =
      trees mapConserve (tree => transform(tree, prefix).asInstanceOf[CaseDef])
  }

  ///////////////////////////////////////////////////////////////////////////
  // Helper methods

  def error(tree: Tree, msg: String) = reporter.error(tree.pos, "ss2js: " + msg)
  def warning(tree: Tree, msg: String) = reporter.warning(tree.pos, "ss2js: " + msg)

  def trace(msg: Any) = if(verbose) println(msg)

  protected def treeInfo(tree: Tree): String = {
    if(tree == null) return "null"
    "cls: " + tree.getClass.getSimpleName +
    "   tpe: " + tree.tpe +
    (if(tree.hasSymbol)
      "   symbol: " + tree.symbol +
      "   sym tpe: " + tree.symbol.tpe +
      (if(tree.symbol != NoSymbol && tree.symbol.owner != NoSymbol)
        "   sym owner: " + tree.symbol.owner else "")
    else "") +
    (if(tree.isDef) "  name: " + tree.asInstanceOf[DefTree].name else "")
  }

  /** Is this an object with a main method */
  def hasMain(tree: Tree) = {
    tree.symbol.hasModuleFlag && tree.isInstanceOf[ImplDef] &&
    tree.asInstanceOf[ImplDef].impl.body.exists { tree =>
      tree.hasSymbol &&
      tree.symbol.decodedName == "main" &&
      tree.symbol.isSourceMethod &&
      tree.symbol.isPublic
    }
  }

  def isUnit(tree: Tree) = tree match {
    case Literal(Constant(())) => true
    case _ => false
  }

  def isUnitish(tree: Tree) = {
    // TODO: properly
      val strtype = tree.tpe.toString()
      strtype.endsWith("Unit") || strtype.endsWith("Nothing")
  }

    /** name to string */
    def doName(n: Name): String = n.decode.trim

    /**
     * Keep track of names in current scope and error duplicates.
     */
    class NameScope {
      private val stack = Stack[(Symbol, HashSet[String])]()
      push(NoSymbol)

      def symbol = stack.top._1
      def push(s: Symbol) = {
        stack.push((s, new HashSet[String]))
      }
      def pop() {
        stack.pop()
      }
      def add(t: SymTree) = {
        val name = doName(t.symbol.name)
        if(!t.isInstanceOf[Function] && !t.symbol.isConstructor) {
          if(!t.symbol.isConstructor && isReserved(name))
            error(t, "reserved word: " + name)
          if(t.symbol.name.isOperatorName)
            error(t, "operator overloading not supported: " + name)
          if(!stack.top._2.add(name))
            error(t, "duplicate item name not allowed in JS scope: " + name)
        }
        name
      }
      def contains(t: SymTree) = stack.top._2.contains(doName(t.symbol.name))
      def addPush(t: SymTree) = {
        val ret = add(t)
        push(t.symbol)
        ret
      }
      def scope[T](t: SymTree)(func: => T) = {
        val name = add(t)
        push(t.symbol)
        val ret = func
        pop()
        ret
      }
    }

    // see https://developer.mozilla.org/en/JavaScript/Reference/Reserved_Words
    private val jsReservedWords = Set(
      "break", "case", "catch", "continue", "debugger", "default", "delete",
      "do", "else", "finally", "for", "function", "if", "in", "instanceof",
      "new", "return", "switch", "this", "throw", "try", "typeof", "var",
      "void", "while", "with",
      "class", "const", "enum", "export", "extends", "import", "super",
      "implements", "interface", "let", "package", "private", "protected",
      "public", "static", "yield",
      "null", "true", "false", "undefined",
      "prototype", "constructor"
      )

    def isReserved(word: String) =
      jsReservedWords.contains(word) || word.startsWith("ss2js_")

    val OUTER = "ss2js_outer"
    val INHERITS = "ss2js_inherits"

}
